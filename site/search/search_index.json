{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Appium Gesture Library","text":"<p>Welcome to the Appium Gesture Actions documentation!  </p> <p>The purpose of this library is to provide a number of gesture/interaction functions for Appium mobile automation. The gestures are platform agnostic, which allows the user to provide a WebElement - or locators for both Android and iOS in the same function call.  </p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install interaction-gesture-actions\n# or\nuv add interaction-gesture-actions\n</code></pre>"},{"location":"#available-functions","title":"Available Functions","text":""},{"location":"#swipe-gestures","title":"Swipe Gestures","text":"<ul> <li>up()</li> <li>down()</li> <li>left()</li> <li>right()</li> <li>next()</li> <li>previous()</li> <li>on_element()</li> <li>element_into_view()</li> </ul>"},{"location":"#drag-and-drop-gestures","title":"Drag and Drop Gestures","text":"<ul> <li>drag_and_drop()</li> </ul>"},{"location":"#pinch-gestures","title":"Pinch Gestures","text":"<ul> <li>open()</li> <li>close()</li> </ul>"},{"location":"#compatibility","title":"Compatibility","text":"<ul> <li>\u2705 Android   Requires: <code>appium driver install uiautomator2</code></li> <li>\u2705 iOS (unverified)   Requires: <code>appium driver install xcuitest</code></li> </ul>"},{"location":"reference/actions/","title":"Actions","text":""},{"location":"reference/actions/#interaction.gesture.actions.GestureActions","title":"<code>GestureActions</code>","text":"<p>A class for enhanced gesture functionality in Appium.</p> Source code in <code>src/interaction/gesture/actions.py</code> <pre><code>class GestureActions:\n    \"\"\"\n    A class for enhanced gesture functionality in Appium.\n    \"\"\"\n\n    def __init__(self, driver: WebDriver, platform: str) -&gt; None:\n        \"\"\"\n        Initialize the GestureActions object.\n\n        Args:\n            driver (WebDriver): The Appium driver instance.\n        \"\"\"\n        self._driver = driver\n        self._platform = platform\n        self._drag_drop: DragAndDropGestures | None = None\n        self._pinch: PinchGestures | None = None\n        self._swipe: SwipeGestures | None = None\n\n    @property\n    def drag_drop(self) -&gt; \"DragAndDropGestures\":\n        \"\"\"Access drag-and-drop related gestures.\"\"\"\n        if self._drag_drop is None:\n            self._drag_drop = DragAndDropGestures(self._driver, self._platform)\n        return self._drag_drop\n\n    @property\n    def pinch(self) -&gt; \"PinchGestures\":\n        \"\"\"Access pinch related gestures.\"\"\"\n        if self._pinch is None:\n            self._pinch = PinchGestures(self._driver, self._platform)\n        return self._pinch\n\n    @property\n    def swipe(self) -&gt; \"SwipeGestures\":\n        \"\"\"Access swipe related gestures.\"\"\"\n        if self._swipe is None:\n            self._swipe = SwipeGestures(self._driver, self._platform)\n        return self._swipe\n</code></pre>"},{"location":"reference/actions/#interaction.gesture.actions.GestureActions.drag_drop","title":"<code>drag_drop: DragAndDropGestures</code>  <code>property</code>","text":"<p>Access drag-and-drop related gestures.</p>"},{"location":"reference/actions/#interaction.gesture.actions.GestureActions.pinch","title":"<code>pinch: PinchGestures</code>  <code>property</code>","text":"<p>Access pinch related gestures.</p>"},{"location":"reference/actions/#interaction.gesture.actions.GestureActions.swipe","title":"<code>swipe: SwipeGestures</code>  <code>property</code>","text":"<p>Access swipe related gestures.</p>"},{"location":"reference/actions/#interaction.gesture.actions.GestureActions.__init__","title":"<code>__init__(driver, platform)</code>","text":"<p>Initialize the GestureActions object.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver</code> <p>The Appium driver instance.</p> required Source code in <code>src/interaction/gesture/actions.py</code> <pre><code>def __init__(self, driver: WebDriver, platform: str) -&gt; None:\n    \"\"\"\n    Initialize the GestureActions object.\n\n    Args:\n        driver (WebDriver): The Appium driver instance.\n    \"\"\"\n    self._driver = driver\n    self._platform = platform\n    self._drag_drop: DragAndDropGestures | None = None\n    self._pinch: PinchGestures | None = None\n    self._swipe: SwipeGestures | None = None\n</code></pre>"},{"location":"reference/calculations/","title":"Calculations","text":""},{"location":"reference/calculations/#interaction.gesture.calculations.calculate_boundaries_and_scrollable_area","title":"<code>calculate_boundaries_and_scrollable_area(driver, **kwargs)</code>","text":"<p>Calculate and return scrolling boundaries and scrollable area based on crop factors.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[dict, dict]</code> <p>A tuple containing two dictionaries: - boundaries: Dictionary with upper, lower, left, and right bounds - scrollable_area: Dictionary with x and y dimensions</p> Source code in <code>src/interaction/gesture/calculations.py</code> <pre><code>def calculate_boundaries_and_scrollable_area(\n    driver: WebDriver, **kwargs: any\n) -&gt; tuple[dict, dict]:\n    \"\"\"\n    Calculate and return scrolling boundaries and scrollable area based on crop factors.\n\n    Returns:\n        tuple: A tuple containing two dictionaries:\n            - boundaries: Dictionary with upper, lower, left, and right bounds\n            - scrollable_area: Dictionary with x and y dimensions\n\n    \"\"\"\n    viewport_width, viewport_height = retrieve_viewport_dimensions(driver)\n    crop_factors = {\n        \"upper_cf\": kwargs.get(\"upper_cf\", 0.20),\n        \"lower_cf\": kwargs.get(\"lower_cf\", 0.90),\n        \"left_cf\": kwargs.get(\"left_cf\", 0.10),\n        \"right_cf\": kwargs.get(\"right_cf\", 0.90),\n    }\n    boundaries = {\n        \"upper\": int(viewport_height * crop_factors[\"upper_cf\"]),\n        \"lower\": int(viewport_height * crop_factors[\"lower_cf\"]),\n        \"left\": int(viewport_width * crop_factors[\"left_cf\"]),\n        \"right\": int(viewport_width * crop_factors[\"right_cf\"]),\n    }\n    scrollable_area = {\n        \"x\": boundaries[\"right\"] - boundaries[\"left\"],\n        \"y\": boundaries[\"lower\"] - boundaries[\"upper\"],\n    }\n\n    return crop_factors, boundaries, scrollable_area\n</code></pre>"},{"location":"reference/calculations/#interaction.gesture.calculations.calculate_element_points","title":"<code>calculate_element_points(element, safe_inset=False)</code>","text":"<p>Calculate various points on an element with optional safety insets.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The WebElement to calculate points for.</p> required <code>safe_inset</code> <code>bool</code> <p>If True, applies a 10% inset to all edge points for safer interaction.         Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, tuple[int, int]]</code> <p>A dictionary containing coordinates of nine points on the element:</p> <code>dict[str, tuple[int, int]]</code> <ul> <li>Corners: top_left, top_right, bottom_left, bottom_right</li> </ul> <code>dict[str, tuple[int, int]]</code> <ul> <li>Edge midpoints: top_mid, right_mid, bottom_mid, left_mid</li> </ul> <code>dict[str, tuple[int, int]]</code> <ul> <li>Center: mid</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the element dimensions are invalid.</p> Source code in <code>src/interaction/gesture/calculations.py</code> <pre><code>def calculate_element_points(\n    element: WebElement, safe_inset: bool = False\n) -&gt; dict[str, tuple[int, int]]:\n    \"\"\"\n    Calculate various points on an element with optional safety insets.\n\n    Args:\n        element: The WebElement to calculate points for.\n        safe_inset: If True, applies a 10% inset to all edge points for safer interaction.\n                    Default is False.\n\n    Returns:\n        A dictionary containing coordinates of nine points on the element:\n        - Corners: top_left, top_right, bottom_left, bottom_right\n        - Edge midpoints: top_mid, right_mid, bottom_mid, left_mid\n        - Center: mid\n\n    Raises:\n        ValueError: If the element dimensions are invalid.\n    \"\"\"\n    try:\n        x, y, width, height = _get_element_coordinates(element)\n\n        mid_x = x + width // 2\n        mid_y = y + height // 2\n        right_x = x + width\n        bottom_y = y + height\n\n        if safe_inset:\n            inset = 0.1  # 10% inset\n            inset_x = int(width * inset)\n            inset_y = int(height * inset)\n\n            return {\n                # Corners\n                \"top_left\": (x + inset_x, y + inset_y),\n                \"top_right\": (right_x - inset_x, y + inset_y),\n                \"bottom_left\": (x + inset_x, bottom_y - inset_y),\n                \"bottom_right\": (right_x - inset_x, bottom_y - inset_y),\n                # Edge midpoints\n                \"top_mid\": (mid_x, y + inset_y),\n                \"right_mid\": (right_x - inset_x, mid_y),\n                \"bottom_mid\": (mid_x, bottom_y - inset_y),\n                \"left_mid\": (x + inset_x, mid_y),\n                # Center point\n                \"mid\": (mid_x, mid_y),\n            }\n\n        return {\n            # Corners\n            \"top_left\": (x, y),\n            \"top_right\": (right_x, y),\n            \"bottom_left\": (x, bottom_y),\n            \"bottom_right\": (right_x, bottom_y),\n            # Edge midpoints\n            \"top_mid\": (mid_x, y),\n            \"right_mid\": (right_x, mid_y),\n            \"bottom_mid\": (mid_x, bottom_y),\n            \"left_mid\": (x, mid_y),\n            # Center point\n            \"mid\": (mid_x, mid_y),\n        }\n\n    except ValueError as e:\n        msg = f\"Failed to calculate element points: {str(e)}\"\n        logger.error(msg)\n        raise\n</code></pre>"},{"location":"reference/calculations/#interaction.gesture.calculations.retrieve_element_location","title":"<code>retrieve_element_location(element)</code>","text":"<p>Retrieve the location of an element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The WebElement to retrieve the location for.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>A tuple containing the x and y coordinates of the element.</p> Source code in <code>src/interaction/gesture/calculations.py</code> <pre><code>def retrieve_element_location(element: WebElement) -&gt; tuple[int, int]:\n    \"\"\"\n    Retrieve the location of an element.\n\n    Args:\n        element: The WebElement to retrieve the location for.\n\n    Returns:\n        A tuple containing the x and y coordinates of the element.\n    \"\"\"\n    try:\n        return element.location[\"x\"], element.location[\"y\"]\n    except TimeoutException as e:\n        msg = f\"Element not found: {str(e)}\"\n        logger.error(msg)\n        raise NoSuchElementException(msg) from e\n</code></pre>"},{"location":"reference/calculations/#interaction.gesture.calculations.retrieve_viewport_dimensions","title":"<code>retrieve_viewport_dimensions(driver)</code>","text":"<p>Retrieve the viewport dimensions from the driver.</p> <p>Returns:</p> Type Description <code>tuple[int, int] | None</code> <p>A tuple of (width, height) or None if dimensions couldn't be retrieved.</p> Source code in <code>src/interaction/gesture/calculations.py</code> <pre><code>def retrieve_viewport_dimensions(driver: WebDriver) -&gt; tuple[int, int] | None:\n    \"\"\"\n    Retrieve the viewport dimensions from the driver.\n\n    Returns:\n        A tuple of (width, height) or None if dimensions couldn't be retrieved.\n    \"\"\"\n    try:\n        viewport = driver.get_window_size()\n        if viewport is None:\n            msg = \"Failed to retrieve viewport dimensions\"\n            raise ViewportError(msg)\n        return viewport[\"width\"], viewport[\"height\"]\n    except WebDriverException as e:\n        msg = f\"Failed to get viewport dimensions: {str(e)}\"\n        logger.error(msg)\n        raise ViewportError(msg) from e\n</code></pre>"},{"location":"reference/drag_and_drop/","title":"Drag and Drop","text":""},{"location":"reference/drag_and_drop/#interaction.gesture.drag_and_drop.DragAndDropGestures","title":"<code>DragAndDropGestures</code>","text":"<p>Access pinch/zoom related gestures.</p> Source code in <code>src/interaction/gesture/drag_and_drop.py</code> <pre><code>class DragAndDropGestures:\n    \"\"\"Access pinch/zoom related gestures.\"\"\"\n\n    def __init__(self, driver: WebDriver, platform: str) -&gt; None:\n        self._driver = driver\n        self._platform = platform\n\n    def drag_and_drop(\n        self,\n        element_source: WebElement,\n        element_target: WebElement,\n        speed: float = 1.0,\n    ) -&gt; None:\n        \"\"\"\n        Perform a drag and drop action from the source element to the target element.\n\n        This function only supports initial and final elements which are both visible within the viewport.\n\n        Args:\n            element_source (WebElement): The source element to begin the drag and drop gesture on.\n            element_target (WebElement): The target element to finish the drag and drop gesture on.\n            speed (float, optional): The velocity of the drag-and-drop gesture as a percentage.\n                For Android, this is multiplied by the device's DPI to calculate the final velocity.\n                For iOS, this value is multiplied by the default value of 400.\n                Defaults to 1.0 (100%).\n        \"\"\"\n        p = DragAndDropParameters(element_source, element_target, speed)\n        try:\n            init_element = calculate_element_points(p.element_source)\n            init_x, init_y = init_element[\"mid\"]\n            final_element = calculate_element_points(p.element_target)\n            final_x, final_y = final_element[\"mid\"]\n\n            return (\n                self._drag_drop_android(init_x, init_y, final_x, final_y, p.speed)\n                if self._platform == \"Android\"\n                else self._drag_drop_ios(init_x, init_y, final_x, final_y, p.speed)\n            )\n        except Exception as e:\n            msg = f\"Failed to perform drag and drop: {str(e)}\"\n            logger.error(msg)\n            raise DragDropError(msg) from e\n\n    def _drag_drop_android(\n        self, init_x: int, init_y: int, final_x: int, final_y: int, speed: float\n    ) -&gt; bool:\n        \"\"\"Execute Android-specific drag-and-drop gesture.\"\"\"\n        dpi = self._driver.get_display_density()\n        velocity = (2500 * dpi) * speed\n        return self._driver.execute_script(\n            \"mobile: dragGesture\",\n            {\n                \"startX\": init_x,\n                \"startY\": init_y,\n                \"endX\": final_x,\n                \"endY\": final_y,\n                \"speed\": velocity,\n            },\n        )\n\n    def _drag_drop_ios(\n        self, init_x: int, init_y: int, final_x: int, final_y: int, speed: float\n    ) -&gt; bool:\n        \"\"\"Execute iOS-specific drag-and-drop gesture.\"\"\"\n        velocity = 400 * speed\n        press_duration = 0.5\n        hold_duration = 0.1\n        return self._driver.execute_script(\n            \"mobile: dragFromToWithVelocity\",\n            {\n                \"pressDuration\": press_duration,\n                \"holdDuration\": hold_duration,\n                \"fromX\": init_x,\n                \"fromY\": init_y,\n                \"toX\": final_x,\n                \"toY\": final_y,\n                \"velocity\": velocity,\n            },\n        )\n</code></pre>"},{"location":"reference/drag_and_drop/#interaction.gesture.drag_and_drop.DragAndDropGestures.drag_and_drop","title":"<code>drag_and_drop(element_source, element_target, speed=1.0)</code>","text":"<p>Perform a drag and drop action from the source element to the target element.</p> <p>This function only supports initial and final elements which are both visible within the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>element_source</code> <code>WebElement</code> <p>The source element to begin the drag and drop gesture on.</p> required <code>element_target</code> <code>WebElement</code> <p>The target element to finish the drag and drop gesture on.</p> required <code>speed</code> <code>float</code> <p>The velocity of the drag-and-drop gesture as a percentage. For Android, this is multiplied by the device's DPI to calculate the final velocity. For iOS, this value is multiplied by the default value of 400. Defaults to 1.0 (100%).</p> <code>1.0</code> Source code in <code>src/interaction/gesture/drag_and_drop.py</code> <pre><code>def drag_and_drop(\n    self,\n    element_source: WebElement,\n    element_target: WebElement,\n    speed: float = 1.0,\n) -&gt; None:\n    \"\"\"\n    Perform a drag and drop action from the source element to the target element.\n\n    This function only supports initial and final elements which are both visible within the viewport.\n\n    Args:\n        element_source (WebElement): The source element to begin the drag and drop gesture on.\n        element_target (WebElement): The target element to finish the drag and drop gesture on.\n        speed (float, optional): The velocity of the drag-and-drop gesture as a percentage.\n            For Android, this is multiplied by the device's DPI to calculate the final velocity.\n            For iOS, this value is multiplied by the default value of 400.\n            Defaults to 1.0 (100%).\n    \"\"\"\n    p = DragAndDropParameters(element_source, element_target, speed)\n    try:\n        init_element = calculate_element_points(p.element_source)\n        init_x, init_y = init_element[\"mid\"]\n        final_element = calculate_element_points(p.element_target)\n        final_x, final_y = final_element[\"mid\"]\n\n        return (\n            self._drag_drop_android(init_x, init_y, final_x, final_y, p.speed)\n            if self._platform == \"Android\"\n            else self._drag_drop_ios(init_x, init_y, final_x, final_y, p.speed)\n        )\n    except Exception as e:\n        msg = f\"Failed to perform drag and drop: {str(e)}\"\n        logger.error(msg)\n        raise DragDropError(msg) from e\n</code></pre>"},{"location":"reference/drag_and_drop/#interaction.gesture.drag_and_drop.DragAndDropParameters","title":"<code>DragAndDropParameters</code>  <code>dataclass</code>","text":"<p>Encapsulates the parameters needed to perform the drag and drop gestures.</p> Source code in <code>src/interaction/gesture/drag_and_drop.py</code> <pre><code>@dataclass\nclass DragAndDropParameters:\n    \"\"\"Encapsulates the parameters needed to perform the drag and drop gestures.\"\"\"\n\n    element_source: WebElement\n    element_target: WebElement\n    _speed: float = 1.0\n\n    @property\n    def speed(self) -&gt; float:\n        \"\"\"Get the velocity factor for the drag and drop gesture.\"\"\"\n        return self._speed\n\n    @speed.setter\n    def speed(self, value: float) -&gt; None:\n        if not 0.0 &lt;= value &lt;= 10.0:\n            msg = f\"Speed must be between 0.0 and 10.0, got {value}\"\n            raise ValueError(msg)\n        self._speed = value\n</code></pre>"},{"location":"reference/drag_and_drop/#interaction.gesture.drag_and_drop.DragAndDropParameters.speed","title":"<code>speed: float</code>  <code>property</code> <code>writable</code>","text":"<p>Get the velocity factor for the drag and drop gesture.</p>"},{"location":"reference/enums/","title":"Enums","text":""},{"location":"reference/enums/#interaction.gesture.enums.Direction","title":"<code>Direction</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Direction of the swipe action.</p> Source code in <code>src/interaction/gesture/enums.py</code> <pre><code>class Direction(Enum):\n    \"\"\"Direction of the swipe action.\"\"\"\n\n    UP = \"up\"\n    DOWN = \"down\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    IN = \"in\"\n    OUT = \"out\"\n</code></pre>"},{"location":"reference/enums/#interaction.gesture.enums.SeekDirection","title":"<code>SeekDirection</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Direction in which to seek for an element.</p> Source code in <code>src/interaction/gesture/enums.py</code> <pre><code>class SeekDirection(Enum):\n    \"\"\"\n    Direction in which to seek for an element.\n    \"\"\"\n\n    UP = \"up\"\n    DOWN = \"down\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"reference/enums/#interaction.gesture.enums.UiSelector","title":"<code>UiSelector</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Android UiSelector method to locate an element.</p> Source code in <code>src/interaction/gesture/enums.py</code> <pre><code>class UiSelector(Enum):\n    \"\"\"\n    Android UiSelector method to locate an element.\n    \"\"\"\n\n    DESC = \"description\"\n    DESC_CONTAINS = \"descriptionContains\"\n    DESC_MATCHES = \"descriptionMatches\"\n    CLASS = \"className\"\n    CLASS_MATCH = \"classNameMatches\"\n    TEXT = \"text\"\n    TEXT_CONTAINS = \"textContains\"\n    TEXT_MATCHES = \"textMatches\"\n    TEXT_STARTS_WITH = \"textStartsWith\"\n</code></pre>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#interaction.gesture.exceptions.DragDropError","title":"<code>DragDropError</code>","text":"<p>               Bases: <code>GestureError</code></p> <p>Raised when a drag and drop operation fails.</p> Source code in <code>src/interaction/gesture/exceptions.py</code> <pre><code>class DragDropError(GestureError):\n    \"\"\"Raised when a drag and drop operation fails.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#interaction.gesture.exceptions.ElementInteractionError","title":"<code>ElementInteractionError</code>","text":"<p>               Bases: <code>GestureError</code></p> <p>Raised when interaction with an element fails.</p> Source code in <code>src/interaction/gesture/exceptions.py</code> <pre><code>class ElementInteractionError(GestureError):\n    \"\"\"Raised when interaction with an element fails.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#interaction.gesture.exceptions.ElementNotInViewError","title":"<code>ElementNotInViewError</code>","text":"<p>               Bases: <code>GestureError</code></p> <p>Raised when an element cannot be brought into view after maximum attempts.</p> Source code in <code>src/interaction/gesture/exceptions.py</code> <pre><code>class ElementNotInViewError(GestureError):\n    \"\"\"Raised when an element cannot be brought into view after maximum attempts.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#interaction.gesture.exceptions.GestureError","title":"<code>GestureError</code>","text":"<p>               Bases: <code>WebDriverException</code></p> <p>Base exception for all gesture-related errors.</p> Source code in <code>src/interaction/gesture/exceptions.py</code> <pre><code>class GestureError(WebDriverException):\n    \"\"\"Base exception for all gesture-related errors.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#interaction.gesture.exceptions.InvalidGestureError","title":"<code>InvalidGestureError</code>","text":"<p>               Bases: <code>GestureError</code></p> <p>Raised when an invalid gesture is attempted.</p> Source code in <code>src/interaction/gesture/exceptions.py</code> <pre><code>class InvalidGestureError(GestureError):\n    \"\"\"Raised when an invalid gesture is attempted.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#interaction.gesture.exceptions.SwipeError","title":"<code>SwipeError</code>","text":"<p>               Bases: <code>GestureError</code></p> <p>Raised when a swipe action fails.</p> Source code in <code>src/interaction/gesture/exceptions.py</code> <pre><code>class SwipeError(GestureError):\n    \"\"\"Raised when a swipe action fails.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#interaction.gesture.exceptions.ViewportError","title":"<code>ViewportError</code>","text":"<p>               Bases: <code>GestureError</code></p> <p>Raised when there are issues with viewport dimensions or calculations.</p> Source code in <code>src/interaction/gesture/exceptions.py</code> <pre><code>class ViewportError(GestureError):\n    \"\"\"Raised when there are issues with viewport dimensions or calculations.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#interaction.gesture.exceptions.ZoomError","title":"<code>ZoomError</code>","text":"<p>               Bases: <code>GestureError</code></p> <p>Raised when a zoom operation fails.</p> Source code in <code>src/interaction/gesture/exceptions.py</code> <pre><code>class ZoomError(GestureError):\n    \"\"\"Raised when a zoom operation fails.\"\"\"\n</code></pre>"},{"location":"reference/pinch/","title":"Pinch","text":""},{"location":"reference/pinch/#interaction.gesture.pinch.PinchGestures","title":"<code>PinchGestures</code>","text":"<p>Access pinch/zoom related gestures.</p> Source code in <code>src/interaction/gesture/pinch.py</code> <pre><code>class PinchGestures:\n    \"\"\"Access pinch/zoom related gestures.\"\"\"\n\n    def __init__(self, driver: WebDriver, platform: str) -&gt; None:\n        self._driver = driver\n        self._platform = platform\n\n    def open(\n        self,\n        element: WebElement,\n        percent: float = 0.75,\n        speed: float = 1.0,\n    ) -&gt; bool:\n        \"\"\"\n        Performs a pinch-open (zoom in) gesture on the specified element.\n\n        This function executes a pinch gesture that spreads two fingers apart, commonly used\n        for zooming in on images, maps, or other content. The implementation differs\n        between Android and iOS platforms.\n\n        Args:\n            element (WebElement): The target element to perform the pinch gesture on.\n            percent (float, optional): The scale factor of the pinch as a percentage (0.0-1.0).\n                Higher values create a larger pinch spread.\n                Defaults to 0.75.\n            speed (float, optional): The velocity of the pinch gesture as a percentage.\n                For Android, this is multiplied by the device's DPI to calculate the final velocity.\n                For iOS, this value is used directly.\n                Defaults to 1.0 (100%).\n\n        Returns:\n            bool: True if the pinch gesture was successfully executed.\n\n        Raises:\n            ZoomError: If the pinch gesture fails to execute, wrapping the underlying\n                platform-specific exception.\n\n        \"\"\"\n        p = PinchParameters(element, percent, speed)\n        try:\n            return (\n                self._pinch_open_android(p.element, p.percent, p.speed)\n                if self._platform == \"Android\"\n                else self._pinch_open_ios(p.element, p.percent, p.speed)\n            )\n        except Exception as e:\n            msg = f\"Failed to perform pinch open: {str(e)}\"\n            logger.error(msg)\n            raise ZoomError(msg) from e\n\n    def _pinch_open_android(self, element: WebElement, percent: float, speed: float) -&gt; bool:\n        \"\"\"Execute Android-specific pinch-open gesture.\"\"\"\n        dpi = self._driver.get_display_density()\n        velocity = (2500 * dpi) * speed\n        return self._driver.execute_script(\n            \"mobile: pinchOpenGesture\",\n            {\n                \"elementId\": element,\n                \"percent\": percent,\n                \"speed\": velocity,\n            },\n        )\n\n    def _pinch_open_ios(self, element: WebElement, percent: float, speed: float) -&gt; bool:\n        \"\"\"Execute iOS-specific pinch gesture.\"\"\"\n        return self._driver.execute_script(\n            \"mobile: pinch\",\n            {\n                \"elementId\": element,\n                \"scale\": percent,\n                \"velocity\": speed,\n            },\n        )\n\n    def close(\n        self,\n        element: WebElement,\n        percent: float = 0.75,\n        speed: float = 1.0,\n    ) -&gt; bool:\n        \"\"\"\n        Performs a pinch-close (zoom out) gesture on the specified element.\n\n        This function executes a pinch gesture that pulls two fingers inward, commonly used\n        for zooming out on images, maps, or other content. The implementation differs\n        between Android and iOS platforms.\n\n        Args:\n            element (WebElement): The target element to perform the pinch gesture on.\n            percent (float, optional): The scale factor of the pinch as a percentage (0.0-1.0).\n                Higher values create a larger pinch pull.\n                On iOS a value &gt; 1 inverts the pinch gesture, therefore the value is * 2.\n                Defaults to 0.75.\n            speed (float, optional): The velocity of the pinch gesture as a percentage.\n                For Android, this is multiplied by the device's DPI to calculate the final velocity.\n                For iOS, this value is used directly.\n                Defaults to 1.0.\n\n        Returns:\n            bool: True if the pinch gesture was successfully executed.\n\n        Raises:\n            ZoomError: If the pinch gesture fails to execute, wrapping the underlying\n                platform-specific exception.\n\n        \"\"\"\n        p = PinchParameters(element, percent, speed)\n        try:\n            return (\n                self._pinch_close_android(p.element, p.percent, p.speed)\n                if self._platform == \"Android\"\n                else self._pinch_close_ios(p.element, p.percent, p.speed)\n            )\n        except Exception as e:\n            msg = f\"Failed to perform pinch close: {str(e)}\"\n            logger.error(msg)\n            raise ZoomError(msg) from e\n\n    def _pinch_close_android(self, element: WebElement, percent: float, speed: float) -&gt; bool:\n        \"\"\"Execute Android-specific pinch-close gesture.\"\"\"\n        dpi = self._driver.get_display_density()\n        velocity = (2500 * dpi) * speed\n        return self._driver.execute_script(\n            \"mobile: pinchCloseGesture\",\n            {\n                \"elementId\": element,\n                \"percent\": percent,\n                \"speed\": velocity,\n            },\n        )\n\n    def _pinch_close_ios(self, element: WebElement, percent: float, speed: float) -&gt; bool:\n        \"\"\"Execute iOS-specific pinch gesture.\"\"\"\n        return self._driver.execute_script(\n            \"mobile: pinch\",\n            {\n                \"elementId\": element,\n                \"scale\": percent * 2,\n                \"velocity\": speed,\n            },\n        )\n</code></pre>"},{"location":"reference/pinch/#interaction.gesture.pinch.PinchGestures.close","title":"<code>close(element, percent=0.75, speed=1.0)</code>","text":"<p>Performs a pinch-close (zoom out) gesture on the specified element.</p> <p>This function executes a pinch gesture that pulls two fingers inward, commonly used for zooming out on images, maps, or other content. The implementation differs between Android and iOS platforms.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The target element to perform the pinch gesture on.</p> required <code>percent</code> <code>float</code> <p>The scale factor of the pinch as a percentage (0.0-1.0). Higher values create a larger pinch pull. On iOS a value &gt; 1 inverts the pinch gesture, therefore the value is * 2. Defaults to 0.75.</p> <code>0.75</code> <code>speed</code> <code>float</code> <p>The velocity of the pinch gesture as a percentage. For Android, this is multiplied by the device's DPI to calculate the final velocity. For iOS, this value is used directly. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the pinch gesture was successfully executed.</p> <p>Raises:</p> Type Description <code>ZoomError</code> <p>If the pinch gesture fails to execute, wrapping the underlying platform-specific exception.</p> Source code in <code>src/interaction/gesture/pinch.py</code> <pre><code>def close(\n    self,\n    element: WebElement,\n    percent: float = 0.75,\n    speed: float = 1.0,\n) -&gt; bool:\n    \"\"\"\n    Performs a pinch-close (zoom out) gesture on the specified element.\n\n    This function executes a pinch gesture that pulls two fingers inward, commonly used\n    for zooming out on images, maps, or other content. The implementation differs\n    between Android and iOS platforms.\n\n    Args:\n        element (WebElement): The target element to perform the pinch gesture on.\n        percent (float, optional): The scale factor of the pinch as a percentage (0.0-1.0).\n            Higher values create a larger pinch pull.\n            On iOS a value &gt; 1 inverts the pinch gesture, therefore the value is * 2.\n            Defaults to 0.75.\n        speed (float, optional): The velocity of the pinch gesture as a percentage.\n            For Android, this is multiplied by the device's DPI to calculate the final velocity.\n            For iOS, this value is used directly.\n            Defaults to 1.0.\n\n    Returns:\n        bool: True if the pinch gesture was successfully executed.\n\n    Raises:\n        ZoomError: If the pinch gesture fails to execute, wrapping the underlying\n            platform-specific exception.\n\n    \"\"\"\n    p = PinchParameters(element, percent, speed)\n    try:\n        return (\n            self._pinch_close_android(p.element, p.percent, p.speed)\n            if self._platform == \"Android\"\n            else self._pinch_close_ios(p.element, p.percent, p.speed)\n        )\n    except Exception as e:\n        msg = f\"Failed to perform pinch close: {str(e)}\"\n        logger.error(msg)\n        raise ZoomError(msg) from e\n</code></pre>"},{"location":"reference/pinch/#interaction.gesture.pinch.PinchGestures.open","title":"<code>open(element, percent=0.75, speed=1.0)</code>","text":"<p>Performs a pinch-open (zoom in) gesture on the specified element.</p> <p>This function executes a pinch gesture that spreads two fingers apart, commonly used for zooming in on images, maps, or other content. The implementation differs between Android and iOS platforms.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>The target element to perform the pinch gesture on.</p> required <code>percent</code> <code>float</code> <p>The scale factor of the pinch as a percentage (0.0-1.0). Higher values create a larger pinch spread. Defaults to 0.75.</p> <code>0.75</code> <code>speed</code> <code>float</code> <p>The velocity of the pinch gesture as a percentage. For Android, this is multiplied by the device's DPI to calculate the final velocity. For iOS, this value is used directly. Defaults to 1.0 (100%).</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the pinch gesture was successfully executed.</p> <p>Raises:</p> Type Description <code>ZoomError</code> <p>If the pinch gesture fails to execute, wrapping the underlying platform-specific exception.</p> Source code in <code>src/interaction/gesture/pinch.py</code> <pre><code>def open(\n    self,\n    element: WebElement,\n    percent: float = 0.75,\n    speed: float = 1.0,\n) -&gt; bool:\n    \"\"\"\n    Performs a pinch-open (zoom in) gesture on the specified element.\n\n    This function executes a pinch gesture that spreads two fingers apart, commonly used\n    for zooming in on images, maps, or other content. The implementation differs\n    between Android and iOS platforms.\n\n    Args:\n        element (WebElement): The target element to perform the pinch gesture on.\n        percent (float, optional): The scale factor of the pinch as a percentage (0.0-1.0).\n            Higher values create a larger pinch spread.\n            Defaults to 0.75.\n        speed (float, optional): The velocity of the pinch gesture as a percentage.\n            For Android, this is multiplied by the device's DPI to calculate the final velocity.\n            For iOS, this value is used directly.\n            Defaults to 1.0 (100%).\n\n    Returns:\n        bool: True if the pinch gesture was successfully executed.\n\n    Raises:\n        ZoomError: If the pinch gesture fails to execute, wrapping the underlying\n            platform-specific exception.\n\n    \"\"\"\n    p = PinchParameters(element, percent, speed)\n    try:\n        return (\n            self._pinch_open_android(p.element, p.percent, p.speed)\n            if self._platform == \"Android\"\n            else self._pinch_open_ios(p.element, p.percent, p.speed)\n        )\n    except Exception as e:\n        msg = f\"Failed to perform pinch open: {str(e)}\"\n        logger.error(msg)\n        raise ZoomError(msg) from e\n</code></pre>"},{"location":"reference/pinch/#interaction.gesture.pinch.PinchParameters","title":"<code>PinchParameters</code>  <code>dataclass</code>","text":"<p>Encapsulates the parameters needed to perform pinch gestures.</p> Source code in <code>src/interaction/gesture/pinch.py</code> <pre><code>@dataclass\nclass PinchParameters:\n    \"\"\"Encapsulates the parameters needed to perform pinch gestures.\"\"\"\n\n    element: WebElement\n    _percent: float = 0.75\n    speed: float = 1.0\n\n    @property\n    def percent(self) -&gt; float:\n        \"\"\"Get the scale factor for the pinch gesture.\"\"\"\n        return self._percent\n\n    @percent.setter\n    def percent(self, value: float) -&gt; None:\n        if not 0.0 &lt;= value &lt;= 1.0:\n            msg = f\"Percent must be between 0.0 and 1.0, got {value}\"\n            raise ValueError(msg)\n        self._percent = value\n</code></pre>"},{"location":"reference/pinch/#interaction.gesture.pinch.PinchParameters.percent","title":"<code>percent: float</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scale factor for the pinch gesture.</p>"},{"location":"reference/swipe/","title":"Swipe","text":""},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures","title":"<code>SwipeGestures</code>","text":"<p>Access swipe related gestures.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>class SwipeGestures:\n    \"\"\"Access swipe related gestures.\"\"\"\n\n    def __init__(self, driver: WebDriver, platform: str) -&gt; None:\n        \"\"\"\n        Initialize the SwipeGestures instance.\n\n        Args:\n            driver (WebDriver): A WebDriver instance providing access to the app.\n            platform (str): The platform type ('Android' or 'iOS').\n\n        \"\"\"\n        self._driver = driver\n        self._platform = platform\n        self._max_attempts = 5\n        self._viewport = self._driver.get_window_size()\n        self._viewport_width = self._viewport[\"width\"]\n        self._viewport_height = self._viewport[\"height\"]\n        self._viewport_x_mid_point = self._viewport_width // 2\n        self._viewport_y_mid_point = self._viewport_height // 2\n        self._crop_factors = {\n            \"upper_cf\": CROP_FACTOR_UPPER,\n            \"lower_cf\": CROP_FACTOR_LOWER,\n            \"left_cf\": CROP_FACTOR_LEFT,\n            \"right_cf\": CROP_FACTOR_RIGHT,\n        }\n        self._boundaries = {\n            \"upper\": int(self._viewport_height * self._crop_factors[\"upper_cf\"]),\n            \"lower\": int(self._viewport_height * self._crop_factors[\"lower_cf\"]),\n            \"left\": int(self._viewport_width * self._crop_factors[\"left_cf\"]),\n            \"right\": int(self._viewport_width * self._crop_factors[\"right_cf\"]),\n        }\n        self._scrollable_area = {\n            \"x\": self._boundaries[\"right\"] - self._boundaries[\"left\"],\n            \"y\": self._boundaries[\"lower\"] - self._boundaries[\"upper\"],\n        }\n\n    def _create_action(self) -&gt; ActionChains:\n        \"\"\"\n        Create an ActionChains object for the driver.\n\n        Returns:\n            ActionChains: The ActionChains object configured for the driver.\n\n        \"\"\"\n        action = ActionChains(self._driver)\n        action.w3c_actions = ActionBuilder(\n            self._driver,\n            mouse=PointerInput(interaction.POINTER_TOUCH, \"touch\"),\n        )\n        return action\n\n    def element_into_view(\n        self,\n        value_a: str | None = None,\n        locator_method_a: AppiumBy = None,\n        value_i: str | None = None,\n        locator_method_i: AppiumBy = None,\n        direction: SeekDirection = SeekDirection.DOWN,\n    ):\n        \"\"\"\n        Swipe to bring an element into view.\n\n        This method performs a swipe gesture to ensure that the specified\n        element described by `value` is within the visible area of the app.\n\n        The method if platform agnostic, this means you can include locators for both scenarios\n        and the function will use the value of `self._platform` to determine which parameters to use.\n\n        Suffixes `_a` and `_i` are for Android and iOS respectively.\n\n        Args:\n            value_a (str): The locator value for the element to swipe to view (e.g., new UiSelector().description(\"Day planted\")).\n            locator_method_a (AppiumBy): The method to locate the element (e.g., AppiumBy.ANDROID_UIAUTOMATOR).\n            value_i (str): The locator value for the element to swipe to view (e.g., label == 'Flowers').\n            locator_method_i (AppiumBy): The method to locate the element (e.g., AppiumBy.IOS_PREDICATE).\n            direction (SeekDirection): The direction to scroll (e.g., SeekDirection.DOWN).\n\n        Raises:\n            ValueError: If the specified platform is unknown or unspecified.\n\n        Android: Supports all locator methods, however UiSelector is highly preferred.\n        iOS: Supports all locator methods, however NSPredicate is highly preferred.\n\n        \"\"\"\n        if self._platform == \"Android\":\n            self._scroll_to_android(value_a, locator_method_a, direction)\n\n        elif self._platform == \"iOS\":\n            self._scroll_to_ios(value_i, locator_method_i, direction)\n\n        else:\n            msg = \"Unspecified or unknown platform.\"\n            raise ValueError(msg)\n\n    def _scroll_to_android(self, value: str, locator_method: AppiumBy, direction: SeekDirection = None) -&gt; bool | None:\n        if locator_method == AppiumBy.ANDROID_UIAUTOMATOR:\n            # ui_selector = kwargs.get(\"ui_selector\").value\n            query = f\"new UiScrollable(new UiSelector().scrollable(true)).scrollIntoView({value})\"\n            self._driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR, query)\n            return True\n        msg = \"Locator was not of type AppiumBy.ANDROID_UIAUTOMATOR or failed to locate element within viewport,\"\n        \"falling back to alternative method.\"\n        logger.info(msg)\n        self._fallback_scroll_to_element(value, locator_method, direction)\n        return None\n\n    def _scroll_to_ios(self, value: str, locator_method: AppiumBy, direction: SeekDirection) -&gt; bool | None:\n        try:\n            element = self._driver.find_element(locator_method, value)\n            self._driver.execute_script(\n                \"mobile: scrollToElement\",\n                {\n                    \"elementId\": element,\n                },\n            )\n        except NoSuchElementException:\n            msg = \"Failed to locate element within viewport, falling back to alternative method.\"\n            logger.info(msg)\n            self._fallback_scroll_to_element(value, locator_method, direction)\n            return None\n        else:\n            return True\n\n    # def _query_builder_uiautomator(self, value: str, locator_method) -&gt; str:\n    #     ui_selector = kwargs.get(\"ui_selector\")\n    #     return f'(new UiSelector().{ui_selector}(\"{value}\"))'\n\n    def _fallback_scroll_to_element(self, value: str, locator_method: AppiumBy, direction: SeekDirection = None) -&gt; bool:\n        action = self._create_action()\n        for _ in range(self._max_attempts):\n            try:\n                element = self._driver.find_element(locator_method, value)\n                element_x, element_y = calculate_element_points(element)[\"mid\"]\n\n                if direction in [SeekDirection.UP, SeekDirection.DOWN]:\n                    self._swipe_element_into_view_vertical(action, element_y, direction)\n                    return True\n                elif direction in [SeekDirection.LEFT, SeekDirection.RIGHT]:  # noqa: RET505\n                    self._swipe_element_into_view_horizontal(\n                        action,\n                        element_x,\n                        direction,\n                    )\n                    return True\n            except NoSuchElementException:\n                swipe_actions = {\n                    SeekDirection.UP: lambda: self._perform_navigation_partial_y(\n                        action,\n                        self._boundaries[\"upper\"],\n                        self._boundaries[\"lower\"],\n                        self._scrollable_area[\"y\"] * -0.4,\n                    ),\n                    SeekDirection.DOWN: lambda: self._perform_navigation_partial_y(\n                        action,\n                        self._boundaries[\"lower\"],\n                        self._boundaries[\"upper\"],\n                        self._scrollable_area[\"y\"] * 0.4,\n                    ),\n                    SeekDirection.LEFT: lambda: self._perform_navigation_partial_x(\n                        action,\n                        self._boundaries[\"left\"],\n                        self._boundaries[\"right\"],\n                        self._scrollable_area[\"x\"] * -0.2,\n                    ),\n                    SeekDirection.RIGHT: lambda: self._perform_navigation_partial_x(\n                        action,\n                        self._boundaries[\"right\"],\n                        self._boundaries[\"left\"],\n                        self._scrollable_area[\"x\"] * 0.2,\n                    ),\n                }\n                swipe_actions[direction]()\n\n        return False\n\n    def up(self) -&gt; None:\n        \"\"\"Perform a full upward swipe of the calculated viewport.\"\"\"\n        action = self._create_action()\n        try:\n            self._perform_navigation_full_y(\n                action, self._boundaries[\"lower\"], self._boundaries[\"upper\"]\n            )\n        except (WebDriverException, KeyError, AttributeError) as e:\n            self._log_and_raise(f\"Failed to swipe up: {e}\", e)\n\n    def down(self) -&gt; None:\n        \"\"\"Perform a full downward swipe of the calculated viewport.\"\"\"\n        action = self._create_action()\n        try:\n            self._perform_navigation_full_y(\n                action, self._boundaries[\"upper\"], self._boundaries[\"lower\"]\n            )\n        except (WebDriverException, KeyError, AttributeError) as e:\n            self._log_and_raise(f\"Failed to swipe down: {e}\", e)\n\n    def left(self) -&gt; None:\n        \"\"\"Perform a full leftward swipe of the calculated viewport.\"\"\"\n        action = self._create_action()\n        try:\n            self._perform_navigation_full_x(\n                action, self._boundaries[\"right\"], self._boundaries[\"left\"]\n            )\n        except (WebDriverException, KeyError, AttributeError) as e:\n            self._log_and_raise(f\"Failed to swipe left: {e}\", e)\n\n    def right(self) -&gt; None:\n        \"\"\"Perform a full rightward swipe of the calculated viewport.\"\"\"\n        action = self._create_action()\n        try:\n            self._perform_navigation_full_x(\n                action, self._boundaries[\"left\"], self._boundaries[\"right\"]\n            )\n        except (WebDriverException, KeyError, AttributeError) as e:\n            self._log_and_raise(f\"Failed to swipe right: {e}\", e)\n\n    def previous(self) -&gt; None:\n        \"\"\"Perform a complete swipe from the left-edge of the viewport.\"\"\"\n        action = self._create_action()\n        try:\n            self._perform_navigation_full_x(action, 0, self._viewport_width)\n        except (WebDriverException, AttributeError) as e:\n            self._log_and_raise(f\"Failed to swipe to previous: {e}\", e)\n\n    def next(self) -&gt; None:\n        \"\"\"Perform a complete swipe from the right-edge of the viewport.\"\"\"\n        action = self._create_action()\n        try:\n            self._perform_navigation_full_x(action, self._viewport_width, 0)\n        except (WebDriverException, AttributeError) as e:\n            self._log_and_raise(f\"Failed to swipe to next: {e}\", e)\n\n    def on_element(self, element: WebElement, direction: Direction) -&gt; None:\n        \"\"\"Swipe on a specific element in the given direction.\"\"\"\n        try:\n            action = self._create_action()\n            element_points = calculate_element_points(element, True)\n\n            points_map = {\n                Direction.UP: (element_points[\"bottom_mid\"], element_points[\"top_mid\"]),\n                Direction.DOWN: (\n                    element_points[\"top_mid\"],\n                    element_points[\"bottom_mid\"],\n                ),\n                Direction.RIGHT: (\n                    element_points[\"left_mid\"],\n                    element_points[\"right_mid\"],\n                ),\n                Direction.LEFT: (\n                    element_points[\"right_mid\"],\n                    element_points[\"left_mid\"],\n                ),\n            }\n\n            self._perform_navigation_on_element(action, *points_map[direction])\n        except (WebDriverException, KeyError, AttributeError, ValueError) as e:\n            self._log_and_raise(f\"Failed to swipe on element: {e}\", e)\n\n    def _swipe_element_into_view_vertical(\n        self, action: ActionChains, element_y: int, direction: SeekDirection\n    ) -&gt; None:\n        \"\"\"Perform vertical swipes to bring an element into view.\"\"\"\n        try:\n            distance_to_element = element_y - self._boundaries[\"lower\"]\n            actions_total = distance_to_element / self._scrollable_area[\"y\"]\n            actions_complete = int(distance_to_element // self._scrollable_area[\"y\"])\n            actions_partial = int(\n                self._scrollable_area[\"y\"] * (actions_total - actions_complete)\n            )\n\n            start, end = (\n                (self._boundaries[\"upper\"], self._boundaries[\"lower\"])\n                if direction == SeekDirection.UP\n                else (self._boundaries[\"lower\"], self._boundaries[\"upper\"])\n            )\n\n            if actions_total &gt; 1:\n                self._perform_navigation_full_y(action, start, end, actions_complete)\n            if actions_partial &gt; SWIPE_ACTION_THRESHOLD:\n                self._perform_navigation_partial_y(action, start, end, actions_partial)\n        except (\n            WebDriverException,\n            KeyError,\n            ZeroDivisionError,\n            TypeError,\n            ValueError,\n        ) as e:\n            self._log_and_raise(f\"Failed to swipe element into view vertically: {e}\", e)\n\n    def _swipe_element_into_view_horizontal(\n        self, action: ActionChains, element_x: int, direction: SeekDirection\n    ) -&gt; None:\n        \"\"\"Perform horizontal swipes to bring an element into view.\"\"\"\n        try:\n            distance_to_element = element_x - self._boundaries[\"left\"]\n            actions_total = distance_to_element / self._scrollable_area[\"x\"]\n            actions_complete = int(distance_to_element // self._scrollable_area[\"x\"])\n            actions_partial = int(\n                self._scrollable_area[\"x\"] * (actions_total - actions_complete)\n            )\n\n            start, end = (\n                (self._boundaries[\"right\"], self._boundaries[\"left\"])\n                if direction == SeekDirection.LEFT\n                else (self._boundaries[\"left\"], self._boundaries[\"right\"])\n            )\n\n            if actions_total &gt; 1:\n                self._perform_navigation_full_x(action, start, end, actions_complete)\n            if actions_partial &gt; SWIPE_ACTION_THRESHOLD:\n                self._perform_navigation_partial_x(action, start, end, actions_partial)\n        except (\n            WebDriverException,\n            KeyError,\n            ZeroDivisionError,\n            TypeError,\n            ValueError,\n        ) as e:\n            self._log_and_raise(\n                f\"Failed to swipe element into view horizontally: {e}\", e\n            )\n\n    def _perform_navigation_full_y(\n        self,\n        action: ActionChains,\n        initial_bound: int,\n        final_bound: int,\n        iterations: int = 1,\n    ) -&gt; None:\n        \"\"\"Perform full vertical navigation swipes.\"\"\"\n        try:\n            for _ in range(iterations):\n                self._perform_swipe(\n                    action,\n                    (self._viewport_x_mid_point, initial_bound),\n                    (self._viewport_x_mid_point, final_bound),\n                )\n                action.perform()\n        except (WebDriverException, AttributeError, ValueError) as e:\n            self._log_and_raise(f\"Failed to perform full vertical navigation: {e}\", e)\n\n    def _perform_navigation_partial_y(\n        self,\n        action: ActionChains,\n        initial_bound: int,\n        final_bound: int,\n        partial_percentage: int,\n    ) -&gt; None:\n        \"\"\"Perform a partial vertical navigation swipe.\"\"\"\n        try:\n            self._perform_swipe(\n                action,\n                (self._viewport_x_mid_point, initial_bound),\n                (self._viewport_x_mid_point, final_bound + partial_percentage),\n            )\n            action.perform()\n        except (WebDriverException, AttributeError, ValueError) as e:\n            self._log_and_raise(\n                f\"Failed to perform partial vertical navigation: {e}\", e\n            )\n\n    def _perform_navigation_full_x(\n        self,\n        action: ActionChains,\n        initial_bound: int,\n        final_bound: int,\n        iterations: int = 1,\n    ) -&gt; None:\n        \"\"\"Perform full horizontal navigation swipes.\"\"\"\n        try:\n            for _ in range(iterations):\n                self._perform_swipe(\n                    action,\n                    (initial_bound, self._viewport_y_mid_point),\n                    (final_bound, self._viewport_y_mid_point),\n                )\n                action.perform()\n        except (WebDriverException, AttributeError, ValueError) as e:\n            self._log_and_raise(f\"Failed to perform full horizontal navigation: {e}\", e)\n\n    def _perform_navigation_partial_x(\n        self,\n        action: ActionChains,\n        initial_bound: int,\n        final_bound: int,\n        partial_percentage: int,\n    ) -&gt; None:\n        \"\"\"Perform a partial horizontal navigation swipe.\"\"\"\n        try:\n            self._perform_swipe(\n                action,\n                (initial_bound, self._viewport_y_mid_point),\n                (final_bound + partial_percentage, self._viewport_y_mid_point),\n            )\n            action.perform()\n        except (WebDriverException, AttributeError, ValueError) as e:\n            self._log_and_raise(\n                f\"Failed to perform partial horizontal navigation: {e}\", e\n            )\n\n    def _perform_navigation_on_element(\n        self,\n        action: ActionChains,\n        initial_bound: tuple[int, int],\n        final_bound: tuple[int, int],\n    ) -&gt; None:\n        \"\"\"Perform a navigation swipe on a specific element.\"\"\"\n        try:\n            self._perform_swipe(action, initial_bound, final_bound)\n            action.perform()\n        except (WebDriverException, AttributeError, ValueError) as e:\n            self._log_and_raise(f\"Failed to perform navigation on element: {e}\", e)\n\n    def _perform_swipe(\n        self, action: ActionChains, start: tuple[int, int], end: tuple[int, int]\n    ) -&gt; None:\n        \"\"\"Perform a swipe action from start to end coordinates.\"\"\"\n        try:\n            action.w3c_actions.pointer_action.move_to_location(*start)\n            action.w3c_actions.pointer_action.pointer_down()\n            action.w3c_actions.pointer_action.move_to_location(*end)\n            action.w3c_actions.pointer_action.pause(0.5)\n            action.w3c_actions.pointer_action.release()\n        except (WebDriverException, AttributeError, ValueError) as e:\n            self._log_and_raise(f\"Failed to perform swipe action: {e}\", e)\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.__init__","title":"<code>__init__(driver, platform)</code>","text":"<p>Initialize the SwipeGestures instance.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver</code> <p>A WebDriver instance providing access to the app.</p> required <code>platform</code> <code>str</code> <p>The platform type ('Android' or 'iOS').</p> required Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def __init__(self, driver: WebDriver, platform: str) -&gt; None:\n    \"\"\"\n    Initialize the SwipeGestures instance.\n\n    Args:\n        driver (WebDriver): A WebDriver instance providing access to the app.\n        platform (str): The platform type ('Android' or 'iOS').\n\n    \"\"\"\n    self._driver = driver\n    self._platform = platform\n    self._max_attempts = 5\n    self._viewport = self._driver.get_window_size()\n    self._viewport_width = self._viewport[\"width\"]\n    self._viewport_height = self._viewport[\"height\"]\n    self._viewport_x_mid_point = self._viewport_width // 2\n    self._viewport_y_mid_point = self._viewport_height // 2\n    self._crop_factors = {\n        \"upper_cf\": CROP_FACTOR_UPPER,\n        \"lower_cf\": CROP_FACTOR_LOWER,\n        \"left_cf\": CROP_FACTOR_LEFT,\n        \"right_cf\": CROP_FACTOR_RIGHT,\n    }\n    self._boundaries = {\n        \"upper\": int(self._viewport_height * self._crop_factors[\"upper_cf\"]),\n        \"lower\": int(self._viewport_height * self._crop_factors[\"lower_cf\"]),\n        \"left\": int(self._viewport_width * self._crop_factors[\"left_cf\"]),\n        \"right\": int(self._viewport_width * self._crop_factors[\"right_cf\"]),\n    }\n    self._scrollable_area = {\n        \"x\": self._boundaries[\"right\"] - self._boundaries[\"left\"],\n        \"y\": self._boundaries[\"lower\"] - self._boundaries[\"upper\"],\n    }\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.down","title":"<code>down()</code>","text":"<p>Perform a full downward swipe of the calculated viewport.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def down(self) -&gt; None:\n    \"\"\"Perform a full downward swipe of the calculated viewport.\"\"\"\n    action = self._create_action()\n    try:\n        self._perform_navigation_full_y(\n            action, self._boundaries[\"upper\"], self._boundaries[\"lower\"]\n        )\n    except (WebDriverException, KeyError, AttributeError) as e:\n        self._log_and_raise(f\"Failed to swipe down: {e}\", e)\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.element_into_view","title":"<code>element_into_view(value_a=None, locator_method_a=None, value_i=None, locator_method_i=None, direction=SeekDirection.DOWN)</code>","text":"<p>Swipe to bring an element into view.</p> <p>This method performs a swipe gesture to ensure that the specified element described by <code>value</code> is within the visible area of the app.</p> <p>The method if platform agnostic, this means you can include locators for both scenarios and the function will use the value of <code>self._platform</code> to determine which parameters to use.</p> <p>Suffixes <code>_a</code> and <code>_i</code> are for Android and iOS respectively.</p> <p>Parameters:</p> Name Type Description Default <code>value_a</code> <code>str</code> <p>The locator value for the element to swipe to view (e.g., new UiSelector().description(\"Day planted\")).</p> <code>None</code> <code>locator_method_a</code> <code>AppiumBy</code> <p>The method to locate the element (e.g., AppiumBy.ANDROID_UIAUTOMATOR).</p> <code>None</code> <code>value_i</code> <code>str</code> <p>The locator value for the element to swipe to view (e.g., label == 'Flowers').</p> <code>None</code> <code>locator_method_i</code> <code>AppiumBy</code> <p>The method to locate the element (e.g., AppiumBy.IOS_PREDICATE).</p> <code>None</code> <code>direction</code> <code>SeekDirection</code> <p>The direction to scroll (e.g., SeekDirection.DOWN).</p> <code>DOWN</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified platform is unknown or unspecified.</p> <p>Android: Supports all locator methods, however UiSelector is highly preferred. iOS: Supports all locator methods, however NSPredicate is highly preferred.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def element_into_view(\n    self,\n    value_a: str | None = None,\n    locator_method_a: AppiumBy = None,\n    value_i: str | None = None,\n    locator_method_i: AppiumBy = None,\n    direction: SeekDirection = SeekDirection.DOWN,\n):\n    \"\"\"\n    Swipe to bring an element into view.\n\n    This method performs a swipe gesture to ensure that the specified\n    element described by `value` is within the visible area of the app.\n\n    The method if platform agnostic, this means you can include locators for both scenarios\n    and the function will use the value of `self._platform` to determine which parameters to use.\n\n    Suffixes `_a` and `_i` are for Android and iOS respectively.\n\n    Args:\n        value_a (str): The locator value for the element to swipe to view (e.g., new UiSelector().description(\"Day planted\")).\n        locator_method_a (AppiumBy): The method to locate the element (e.g., AppiumBy.ANDROID_UIAUTOMATOR).\n        value_i (str): The locator value for the element to swipe to view (e.g., label == 'Flowers').\n        locator_method_i (AppiumBy): The method to locate the element (e.g., AppiumBy.IOS_PREDICATE).\n        direction (SeekDirection): The direction to scroll (e.g., SeekDirection.DOWN).\n\n    Raises:\n        ValueError: If the specified platform is unknown or unspecified.\n\n    Android: Supports all locator methods, however UiSelector is highly preferred.\n    iOS: Supports all locator methods, however NSPredicate is highly preferred.\n\n    \"\"\"\n    if self._platform == \"Android\":\n        self._scroll_to_android(value_a, locator_method_a, direction)\n\n    elif self._platform == \"iOS\":\n        self._scroll_to_ios(value_i, locator_method_i, direction)\n\n    else:\n        msg = \"Unspecified or unknown platform.\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.left","title":"<code>left()</code>","text":"<p>Perform a full leftward swipe of the calculated viewport.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def left(self) -&gt; None:\n    \"\"\"Perform a full leftward swipe of the calculated viewport.\"\"\"\n    action = self._create_action()\n    try:\n        self._perform_navigation_full_x(\n            action, self._boundaries[\"right\"], self._boundaries[\"left\"]\n        )\n    except (WebDriverException, KeyError, AttributeError) as e:\n        self._log_and_raise(f\"Failed to swipe left: {e}\", e)\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.next","title":"<code>next()</code>","text":"<p>Perform a complete swipe from the right-edge of the viewport.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def next(self) -&gt; None:\n    \"\"\"Perform a complete swipe from the right-edge of the viewport.\"\"\"\n    action = self._create_action()\n    try:\n        self._perform_navigation_full_x(action, self._viewport_width, 0)\n    except (WebDriverException, AttributeError) as e:\n        self._log_and_raise(f\"Failed to swipe to next: {e}\", e)\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.on_element","title":"<code>on_element(element, direction)</code>","text":"<p>Swipe on a specific element in the given direction.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def on_element(self, element: WebElement, direction: Direction) -&gt; None:\n    \"\"\"Swipe on a specific element in the given direction.\"\"\"\n    try:\n        action = self._create_action()\n        element_points = calculate_element_points(element, True)\n\n        points_map = {\n            Direction.UP: (element_points[\"bottom_mid\"], element_points[\"top_mid\"]),\n            Direction.DOWN: (\n                element_points[\"top_mid\"],\n                element_points[\"bottom_mid\"],\n            ),\n            Direction.RIGHT: (\n                element_points[\"left_mid\"],\n                element_points[\"right_mid\"],\n            ),\n            Direction.LEFT: (\n                element_points[\"right_mid\"],\n                element_points[\"left_mid\"],\n            ),\n        }\n\n        self._perform_navigation_on_element(action, *points_map[direction])\n    except (WebDriverException, KeyError, AttributeError, ValueError) as e:\n        self._log_and_raise(f\"Failed to swipe on element: {e}\", e)\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.previous","title":"<code>previous()</code>","text":"<p>Perform a complete swipe from the left-edge of the viewport.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def previous(self) -&gt; None:\n    \"\"\"Perform a complete swipe from the left-edge of the viewport.\"\"\"\n    action = self._create_action()\n    try:\n        self._perform_navigation_full_x(action, 0, self._viewport_width)\n    except (WebDriverException, AttributeError) as e:\n        self._log_and_raise(f\"Failed to swipe to previous: {e}\", e)\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.right","title":"<code>right()</code>","text":"<p>Perform a full rightward swipe of the calculated viewport.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def right(self) -&gt; None:\n    \"\"\"Perform a full rightward swipe of the calculated viewport.\"\"\"\n    action = self._create_action()\n    try:\n        self._perform_navigation_full_x(\n            action, self._boundaries[\"left\"], self._boundaries[\"right\"]\n        )\n    except (WebDriverException, KeyError, AttributeError) as e:\n        self._log_and_raise(f\"Failed to swipe right: {e}\", e)\n</code></pre>"},{"location":"reference/swipe/#interaction.gesture.swipe.SwipeGestures.up","title":"<code>up()</code>","text":"<p>Perform a full upward swipe of the calculated viewport.</p> Source code in <code>src/interaction/gesture/swipe.py</code> <pre><code>def up(self) -&gt; None:\n    \"\"\"Perform a full upward swipe of the calculated viewport.\"\"\"\n    action = self._create_action()\n    try:\n        self._perform_navigation_full_y(\n            action, self._boundaries[\"lower\"], self._boundaries[\"upper\"]\n        )\n    except (WebDriverException, KeyError, AttributeError) as e:\n        self._log_and_raise(f\"Failed to swipe up: {e}\", e)\n</code></pre>"}]}